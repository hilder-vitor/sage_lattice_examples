from sage.modules.free_module_integer import IntegerLattice as Lattice

N = 4  # Degree of polynomial used as modulus and dimension of lattice
Zx.<x> = ZZ['x']
f = x^N + 1     # modulus defining Zx / <f>


q = random_prime(N**10, N**9)
Zq = GF(q)
Rq = Zq['x'].quotient(f)

print "Ring: ZZ[x]/<", f, ">"
print "q =", q

B_g = N
B_M = N
B_E = 3 #int(q**(1/10))


g = Zx.random_element(randint(N/2,N-1), -B_g, B_g)
print "g =", g

# return a polynomial h in Zx such that h*g = 1 over Rq,
# or, equivalently,  ((h*g mod f) mod q) = 1 over ZZ['x']
def inverse_polynomial(g):
    return Zx((1 / Rq(g)).lift().coefficients(sparse=False))


z = Zx.random_element(randint(0,N-1), int(-q/2), int(q/2))
inv_z = inverse_polynomial(z)

print "z =", z
assert 1 == ((z * inv_z % f) %q)


def phi(h): # isomorphism from Zx/f to Z^n (return a vector representing h)
    v = h.coefficients(sparse=False)
    return v + [0]*(N - len(v))

def inv_phi(vec_h): # isomorphism from Z^n to ZZ['x']/f (return the polynomial represented by vec_h)
    return Zx([ai for ai in vec_h])

# Return a matrix H such that for any p in Zx/<f>, H*phi(p) equals h*p % f,
# that is, the matrix that represents the product by the polynomial h.
def matrix_polynomial_product(h):
    H = Matrix(ZZ, [phi(h * x^i % f) for i in xrange(N)])
    return H.transpose()

def centered_mod(h):
    vec_h = h.coefficients(sparse=False)
    return Zx([Zq(ai).lift_centered() for ai in vec_h])

def size(poly):
    return vector(ZZ, phi(poly)).norm(p=Infinity)

# All the vectors in L are supposed to have the format 
#     phi(u*q + c1*a % f + c2*b % f) || phi(a)|| phi(b)
# for some vectors u, a, and b of Zx/<f>.
# This function receives a v from L and return such polynomials u, a, and b.
def lattice_point_to_polys(v):
    v = list(v) # treat vector over ZZ as a simple list

    a = inv_phi(v[0:N]) # polynomial corresponding to the first N entries
    b = inv_phi(v[N:2*N])
    
    # assert that the lattice vector v has the format
    # (u*q + c1*a % f + c2*b % f, a, b)
    # or, equivalently, that v = (v0, a, b) with
    # a*c1 + b*c2 = v0 in Zx/<f,q> (mod f and mod q)
    assert 0 == Rq(a*c1 + b*c2)

    return a, b

def encode(m):
    r = Zx.random_element(randint(N/2,N-1), -B_E, B_E)
    return centered_mod(((r*g + m) * inv_z) % f), r # returning the error for debugging

# polynomial with random degree and coefficients in [-B_M, B_M]
m1 = Zx.random_element(randint(0,g.degree()-1), -B_M, B_M) 
c1, r1 = encode(m1)

print "c1 =", c1
c1xz = centered_mod((c1 * z % f))
assert (size(c1xz) <= B_M + 2*N*B_g*B_E)
assert Rq(c1xz) == Rq(m1 + g*r1)

inv_c1 = inverse_polynomial(c1)
#print "inv_c1 =", inv_c1
assert 1 == Rq(c1 * inv_c1)

m2 = Zx.random_element(randint(0,g.degree()-1), -B_M, B_M) 
c2, r2 = encode(m2)
c2xz = centered_mod(c2 * z % f)
print "c2 =", c2

assert (size(c2xz) <= B_M + 2*N*B_g*B_E)
assert Rq(c2xz) == Rq(m2 + g*r2)

inv_C1 = matrix_polynomial_product(inv_c1)
C2_times_inv_C1 = matrix_polynomial_product(c2*inv_c1 % f)

# assert that matrix C2_times_inv_C1 satisfy the property
# C2_times_inv_C1 * phi(c1) == c2 mod q
assert Rq(c2) == Rq(inv_phi(C2_times_inv_C1 * vector(phi(c1))))


B = block_matrix(ZZ, [[-C2_times_inv_C1.transpose(), 1], [q*Matrix.identity(N), 0]]) # inv_C1, 0], [-C2_times_inv_C1, 1]])
print B
L = Lattice(B) # Lattice generated by the rows of B

## Test if the lattice vectors have the expected format
for i in xrange(100):
    v = L.random_element() 
    a, b = lattice_point_to_polys(v)


#v = L.shortest_vector()
L.LLL()
v = L.reduced_basis[0] # select the first vector of the reduced basis as a solution

a, b = lattice_point_to_polys(v) # extract the two polynomials from the lattice point v
print "a =", a
print "b =", b

print "Targets:"
print "c2 * z =", c2xz
print "c1 * z =", c1xz

#   All the cyclic rotation have the same norm, so, c1*x, c1*x^2, etc 
# can be returned instead of simply c1 (and the same goes for c2)
a_has_expected_format = False
for i in xrange(2*N):
    rotated_a = centered_mod(a*x^i % f)
    if rotated_a == c2xz:
        a_has_expected_format = True
        print "a*x^%d == c2*z == m2 + g*r2" % i
        break
b_has_expected_format = False
for i in xrange(2*N):
    rotated_b = b*x^i % f
    if rotated_b == c1xz:
        print "b*x^%d == c1*z == m1 + g*r1" % i
        b_has_expected_format = True
        break

if a_has_expected_format:
    print "a is OK."
else:
    print "a is NOT OK."

if b_has_expected_format:
    print "b is OK."
else:
    print "b is NOT OK."
