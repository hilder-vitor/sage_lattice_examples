from sage.modules.free_module_integer import IntegerLattice as Lattice

N = 2**3  # Degree of polynomial used as modulus and dimension of lattice
Zx.<x> = ZZ['x']
f = x^N + 1     # modulus defining Zx / <f>

R = Zx.quotient(f)

q = random_prime(N**10, N**9)
Zq = GF(q)
Rq = Zq['x'].quotient(f)

print "Ring: ZZ[x]/<", f, ">"
print "q =", q

B_g = N
B_M = N
B_E = N #int(q**(1/10))


g = Zx.random_element(randint(N/2,N-1), -B_g, B_g)
print "g =", g

# return a polynomial h in Zx such that h*g = 1 over Rq,
# or, equivalently,  ((h*g mod f) mod q) = 1 over ZZ['x']
def inverse_polynomial(g):
    return Zx((1 / Rq(g)).lift().coefficients(sparse=False))


z = Zx.random_element(randint(0,N-1), int(-q/2), int(q/2))
inv_z = inverse_polynomial(z)

print "z =", z
assert 1 == ((z * inv_z % f) %q)


def phi(h): # isomorphism from Zx/f to Z^n (return a vector representing h)
    v = h.coefficients(sparse=False)
    return v + [0]*(N - len(v))

def inv_phi(vec_h): # isomorphism from Z^n to ZZ['x']/f (return the polynomial represented by vec_h)
    return Zx([ai for ai in vec_h])

# Return a matrix H such that for any p in Zx/<f>, H*phi(p) equals h*p % f,
# that is, the matrix that represents the product by the polynomial h.
def matrix_polynomial_product(h):
    H = Matrix(ZZ, [phi(h * x^i % f) for i in xrange(N)])
    return H.transpose()

def centered_mod(h):
    vec_h = h.coefficients(sparse=False)
    return Zx([Zq(ai).lift_centered() for ai in vec_h])

def size(poly):
    return vector(ZZ, phi(poly)).norm(p=Infinity)

# All the vectors in L are supposed to have the format 
#     phi(u*q + c1*a % f + c2*b % f) || phi(a)|| phi(b)
# for some vectors u, a, and b of Zx/<f>.
# This function receives a v from L and return such polynomials u, a, and b.
def lattice_point_to_polys(v):
    v = list(v) # treat vector over ZZ as a simple list

    a = inv_phi(v[0:N]) # polynomial corresponding to the first N entries
    b = inv_phi(v[N:2*N])
    
    # assert that the lattice vector v has the format
    # (u*q + c1*a % f + c2*b % f, a, b)
    # or, equivalently, that v = (v0, a, b) with
    # a*c1 + b*c2 = v0 in Zx/<f,q> (mod f and mod q)
    assert 0 == Rq(a*c1 + b*c2)

    return a, b

def encode(m):
    r = Zx.random_element(randint(N/2,N-1), -B_E, B_E)
    return centered_mod(((r*g + m) * inv_z) % f), r # returning the error for debugging

# polynomial with random degree and coefficients in [-B_M, B_M]
m1 = Zx.random_element(randint(0,g.degree()-1), -B_M, B_M) 
c1, r1 = encode(m1)

print "c1 =", c1
c1xz = centered_mod((c1 * z % f))
assert (size(c1xz) <= B_M + 2*N*B_g*B_E)
assert Rq(c1xz) == Rq(m1 + g*r1)

inv_c1 = inverse_polynomial(c1)
#print "inv_c1 =", inv_c1
assert 1 == Rq(c1 * inv_c1)

m2 = Zx.random_element(randint(0,g.degree()-1), -B_M, B_M) 
c2, r2 = encode(m2)
c2xz = centered_mod(c2 * z % f)
print "c2 =", c2

assert (size(c2xz) <= B_M + 2*N*B_g*B_E)
assert Rq(c2xz) == Rq(m2 + g*r2)

inv_C1 = matrix_polynomial_product(inv_c1)
C2_times_inv_C1 = matrix_polynomial_product(c2*inv_c1 % f)

# assert that matrix C2_times_inv_C1 satisfy the property
# C2_times_inv_C1 * phi(c1) == c2 mod q
assert Rq(c2) == Rq(inv_phi(C2_times_inv_C1 * vector(phi(c1))))


B = block_matrix(ZZ, [[-C2_times_inv_C1.transpose(), 1], [q*Matrix.identity(N), 0]]) # inv_C1, 0], [-C2_times_inv_C1, 1]])
print B
L = Lattice(B) # Lattice generated by the rows of B

#v = L.shortest_vector()
L.LLL()
v = L.reduced_basis[0] # select the first vector of the reduced basis as a solution

a, b = lattice_point_to_polys(v) # extract the two polynomials from the lattice point v
print "a =", a
print "b =", b

#   All the cyclic rotation have the same norm, so, c1*x, c1*x^2, etc 
# can be returned instead of simply c1 (and the same goes for c2)
a_has_expected_format = False
for k2 in xrange(2*N):
    rotated_a = centered_mod(a*x^k2 % f)
    if rotated_a == c2xz:
        a_has_expected_format = True
        print "a*x^%d == c2*z == m2 + g*r2" % k2
        break
b_has_expected_format = False
for k1 in xrange(2*N):
    rotated_b = b*x^k1 % f
    if rotated_b == c1xz:
        print "b*x^%d == c1*z == m1 + g*r1" % k1
        b_has_expected_format = True
        break

if not (a_has_expected_format and b_has_expected_format):
    if a_has_expected_format:
        print "a is NOT OK."
    else:
        print "b is NOT OK."
    exit(1)

print("")

### Therefore, using two encodings c1 and c2, and a lattice reduction, we can recover (a rotated) z mod q
aprox_z = ((a * inverse_polynomial(c2) % f) % q)  # must be equal to z*x^(2N - k2)

print "Original z:", z
print "z * x^(2N-k2) =", centered_mod(z * x^(2*N-k2) % f)
print "recovered z =", centered_mod(aprox_z)
assert (Rq(z * x^(2*N-k2)) == Rq(aprox_z))

print("")

#### In addition, using an encoding of zero, we can recover small multiple of g 
enc_zero_level_one, r = encode(0)

aprox_g_times_r = centered_mod(enc_zero_level_one * aprox_z % f)

print "Recovered  g_times_r . . . . . . . . .", aprox_g_times_r
print "Original g_times_r * x^(2N -k2)  . . .", (g*r*x^(2*N - k2) % f) # without reduction mod q
print "Original g_times_r   . . . . . . . . .", centered_mod(g*r % f)

####  Using yet another encoding of zero, we should be able to recover (a rotated) g
#another_enc_zero_level_one, r2 = encode(0)
#aprox_g_times_r2 = centered_mod(another_enc_zero_level_one * aprox_z % f)
#
#print "Recovered  g_times_r2 . . . . . . . . .", aprox_g_times_r2
#print "Original g_times_r2 * x^(2N -k2)  . . .", (g*r2*x^(2*N - k2) % f) # without reduction mod q
#print "Original g_times_r2   . . . . . . . . .", centered_mod(g*r % f)
#
#aprox_g = my_gcd(aprox_g_times_r, aprox_g_times_r2)
#print "Recovered g . . . . . . . .", aprox_g
#print "Original g * x^(2N -k2) . .", (g*(2*N -k2) % f)
#print "Original g  . . . . . . . .", g
