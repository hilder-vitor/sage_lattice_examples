from sage.modules.free_module_integer import IntegerLattice as Lattice

N = 4  # Degree of polynomial used as modulus and dimension of lattice
Zx.<x> = ZZ['x']
f = x^N + 1     # modulus defining Zx / <f>

q = random_prime(1000, 500)
Zq = GF(q)
Rq = Zq['x'].quotient(f)

print "Ring: ZZ[x]/<", f, ">"
print "q =", q

# return a polynomial h in Zx such that h*g = 1 over Rq,
# or, equivalently,  ((h*g mod f) mod q) = 1 over ZZ['x']
def inverse_polynomial(g):
    return Zx((1 / Rq(g)).lift().coefficients(sparse=False))

def phi(h): # isomorphism from Zx/f to Z^n (return a vector representing h)
    v = h.coefficients(sparse=False)
    return v + [0]*(N - len(v))

def inv_phi(vec_h): # isomorphism from Z^n to ZZ['x']/f (return the polynomial represented by vec_h)
    return Zx([ai for ai in vec_h])


# Return a matrix H such that for any p in Zx/<f>, H*phi(p) equals h*p % f,
# that is, the matrix that represents the product by the polynomial h.
def matrix_polynomial_product(h):
    H = Matrix(ZZ, [phi(h * x^i % f) for i in xrange(N)])
    return H.transpose()

# All the vectors in L are supposed to have the format 
#     phi(u*q + c1*a % f + c2*b % f) || phi(a)|| phi(b)
# for some vectors u, a, and b of Zx/<f>.
# This function receives a v from L and return such polynomials u, a, and b.
def lattice_point_to_polys(v):
    v = list(v) # treat vector over ZZ as a simple list

    a = inv_phi(v[0:N]) # polynomial corresponding to the first N entries
    b = inv_phi(v[N:2*N])
    
    # assert that the lattice vector v has the format
    # (u*q + c1*a % f + c2*b % f, a, b)
    # or, equivalently, that v = (v0, a, b) with
    # a*c1 + b*c2 = v0 in Zx/<f,q> (mod f and mod q)
    assert 0 == Rq(a*c1 + b*c2)

    return a, b


bound = 4
# polynomial with random degree and coefficients in [-bound, bound]
c1 = Zx.random_element(randint(0,N-1), -bound, bound) 
inv_c1 = inverse_polynomial(c1)

print "c1 =", c1
print "inv_c1 =", inv_c1
assert 1 == Rq(c1 * inv_c1)

c2 = Zx.random_element(randint(0,N-1), -bound, bound) 
print "c2 =", c2

inv_C1 = matrix_polynomial_product(inv_c1)
C2_times_inv_C1 = matrix_polynomial_product(c2*inv_c1 % f)

# assert that matrix C2_times_inv_C1 satisfy the property
# C2_times_inv_C1 * phi(c1) == c2 mod q
assert Rq(c2) == Rq(inv_phi(C2_times_inv_C1 * vector(phi(c1))))


B = block_matrix(ZZ, [[-C2_times_inv_C1.transpose(), 1], [q*Matrix.identity(N), 0]]) # inv_C1, 0], [-C2_times_inv_C1, 1]])
print B
L = Lattice(B) # Lattice generated by the rows of B

## Test if the lattice vectors have the expected format
for i in xrange(100):
    v = L.random_element() 
    a, b = lattice_point_to_polys(v)
print "Lattice points have the expected format."


v = L.shortest_vector()
print "Shortest (nonzero) vector of L:"
print v
a, b = lattice_point_to_polys(v)
print "a =", a
print "b =", b

print "a*c1 + b*c2 % f =", ((a*c1 + b*c2) % f)

#   All the cyclic rotation have the same norm, so, c1*x, c1*x^2, etc 
# can be returned instead of simply c1 (and the same goes for c2)
a_has_expected_format = False
for i in xrange(N):
    if ((a*x^i % f) == c2 or (a*x^i % f) == -1*c2):
        a_has_expected_format = True
        break
b_has_expected_format = False
for i in xrange(N):
    if ((b*x^i % f) == c1 or (b*x^i % f) == -1*c1):
        b_has_expected_format = True
        break

if a_has_expected_format:
    print "a is OK."
else:
    print "a is NOT OK."

if b_has_expected_format:
    print "b is OK."
else:
    print "b is NOT OK."
