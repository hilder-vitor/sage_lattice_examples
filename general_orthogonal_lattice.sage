from sage.modules.free_module_integer import IntegerLattice as Lattice

######################################################################
#   In the second section of the article
# "Merkle-Hellman Revisited: A Cryptanalysis of the Qu-Vanstone
# Cryptosystem Based on Group Factorizations", the authors
# Phong Nguyen and Jacques Stern present a method to construct
# the lattice orthogonal to any given set of vectors.
#   This sage script implements that method. Notice that the value of
# the constant c used here can probably be reduced. Also, pay attention
# to the fact that here n stands to the number of vectors and d to the
# dimension of the vectors (while on the article, it is the converse).
#######################################################################



#    This function receives a list of vectors b1, ..., bn
# of same dimension d (with n <= d) and returns the lattice
# orthogonal to L(b1, ..., bn). That is, it returns the lattice
#   L = {u in Z^d : for all v in L(b1, ..., bn), <u,v> = 0}
# where 
#   L(b1, ..., bn) is the lattice generated by the integer linear
# combinations of b1, ..., bn.
def orthogonal_lattice(list_of_basis_vectors):
    n = len(list_of_basis_vectors)
    d = len(list_of_basis_vectors[0])
    _B = Matrix(ZZ, n, d, list_of_basis_vectors)
    prod_vec = product([vector(ZZ, bi).norm() for bi in list_of_basis_vectors]) # ||b1|| * ... * ||bn||
    c = ZZ(ceil(2**((d-1)/2 + (d-n)*(d-n-1)/4) * prod_vec))
    B_aux = block_matrix([[c * _B], [1]]) # collums of B_aux are the basis of the auxiliary lattice
    L_aux = Lattice(B_aux.transpose(), lll_reduce = True) # taking transpose because sage spans the lattice using the rows of the given matrix

    basis_orthogonal = [L_aux.reduced_basis[i][-d:] for i in xrange(d-n)] # This [-d:] is used to take only the last d entries of each vector

    return Lattice(basis_orthogonal, lll_reduce = False) # B_ort is already an LLL-reduced basis



n = 6
d = 10 # dimension must be greater than the number of vectors: d > n

list_of_vectors = [vector([ZZ.random_element(1, n*d) for i in xrange(d)]) for j in xrange(n)]
L = Lattice(list_of_vectors, lll_reduce=False)
assert(L.rank() == n) # test if the random vectors are linearly independent
print "Original lattice:"
print L

L_ort = orthogonal_lattice(list_of_vectors)

#    Assert that all the vectors in the basis of the orthogonal lattices
# are othogonal to the vectors in the basis of the original lattice.
for bi in list_of_vectors:
    for bj_ort in L_ort.reduced_basis:
        assert(0 == bj_ort * bi)

print "Vectors in L_orthogonal are orthogonal to b1,...,bn"


assert(L_ort.rank() == d-n)
print "Orthogonal lattice has rank d-n as expected."

print "det(L) =", L.volume()
print "det(L_ort) =", L_ort.volume()

print "det(L) / det(L_ort) = %.3f" % (L.volume() / L_ort.volume()).n()

